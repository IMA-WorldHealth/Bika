<link href="units/budgeting/budget.css" rel="stylesheet">
<div id="bika-units-budgeting-selection">
  <!--Placeholder for Account Select-->
  <label>Select Account: </label>
  <div id="bika-units-budgeting-account"></div>
</div>
<div id="bika-units-budgeting-budgetDisplay">
  <fieldset>
    <legend>Previous Fiscal Year</legend>
    <table class="budget-table">
      <thead>
        <tr><th>Period</th><th>Actual</th><th>Budget</th></tr>
      </thead>
      <tbody id="bika-units-budgeting-previous">
        <!--Generated with dojo-->
      </tbody>
    </table>
  </fieldset>
  <fieldset>
    <legend>Current Fiscal Year</legend>
    <table class="budget-table">
      <thead>
        <tr><th>Period</th><th>Actual</th><th>Budget</th></tr>
      </thead>
      <tbody id="bika-units-budgeting-current">
        <!--Generated with dojo-->
      </tbody>
    </table>
  </fieldset>
  <fieldset>
    <legend>Next Fiscal Year</legend>
    <table class="budget-table">
      <thead>
        <tr><th>Period</th><th>Actual</th><th>Budget</th></tr>
      </thead>
      <tbody id="bika-units-budgeting-next">
        <!--Generated with dojo-->
      </tbody>
    </table>
  </fieldset>
</div>

<div id="bika-units-budgeting-controls">
  <button id="bika-units-budgeting-submit" disabled>Submit Budget</button>
  <button id="bika-units-budgeting-reset" disabled>Reset</button>
</div>

<script>
  require([
      //DOM manipulation
      "dojo/dom", 
      "dojo/dom-construct", 
      "dojo/query",
      "dojo/dom-attr", 
      //Stores
      "dojo/store/Memory",
      "dojo/store/Cache",
      "dojo/store/JsonRest",
      "dojo/store/Observable",
      //AJAX
      "dojo/request",
      //Async
      "dojo/on",
      "dojo/Deferred",
      //Components
      "dijit/form/Select",
      //ApplicationState [TEST]
      "bika/ApplicationState"
      ], function(dom, domConstruct, query, domAttr, Memory, Cache, JsonRest, Observable, request, on, Deferred, Select, ApplicationState){ 

    ///////
    // module : budgeting
    // 
    // TODO: 
    //  -[Discuss] Functions inside functions created every time a function is called? Place common functions at top level?
    //  -[Discuss] Should this just be done with D-Grid to provide uniform table structure
    //  -[Discuss] I read somewhere that var newFunc = function() { } is better practice than function() { }, is that true?
    //  -Flush budget changes to server (waiting on update of db.js)
    //  -Unique ID for budget table (ref: Store rant in code)
    //  -Highlighting for errors on incorrect inputs for budgeting etc (Red box around invalid input)
    //  -If changes to budget are made, user should not be able to change accounts until discarded (reset) or updated
    //  -Highlight Start of fiscal year (row outline) ?End of fiscal year
    //  -Some object are getting thrown initialised and sticking around way too long (ref: models etc. on view refresh)
    ///////
    
    /////
    // This update: 
    //  -respond to enterprise and fiscal select changes
    //  -refresh / remove rows manually - have them respond to changes to the store in future 
    //  -
    /////

    var uid = "bika-units-budgeting";
    //TODO: return an initialised object, should not have to manually create instance
    var app_state = new ApplicationState();
    //label months provided by Date object (given 0 - 11)
    var months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

    var enterprise_id = app_state.getValue("enterprise-select");
    var fiscal_year_id = app_state.getValue("fiscal-select");

    //Value set with account-select
    var account_id;
    var account_select;

    //@sfount - re-write this to inject these value all the way through, stupid to have them accesible to everyone
    var tablebind = {};
    var fiscal_array = [{id : "previous"}, {id : "current"}, {id : "next"}];

    //This should be encapsulated somewhere
    var budget_dependencies = {"enterprise" : false, "fiscal" : true};

    //access to any application level componenet changes
    app_state.register(uid, "enterprise-select", function(value) { 
      //Change will effect both enterprise AND fiscal, have to wait for dependencies, TODO determine dependencies from code
      console.log(uid, "responding to: ", value);
      budget_dependencies.enterprise = true;
      account_id = value;
      
      //Should make a call to updateAccount as well
    });

    app_state.register(uid, "fiscal-select", function(value) { 
      //Change will only effect fiscal year, no need to udpate account, TODO determine dependencies from code
      console.log(uid, "responding to: ", value);
      budget_dependencies.fiscal = true;
      fiscal_year_id = value;

      //really think this one through 
      if(budget_dependencies.enterprise) { 
        updateAccount(account_id);
      } else { 
        budget_dependencies.fiscal = false;
        refreshUI();
        settupBudget(fiscal_year_id, account_id);
      }
    });
    
    initUI();

    function initUI() { 

      //Split into seperate functions to allow multiple components to be rendered in order
      renderTables();

      var settupAccount = initAccountSelect(enterprise_id);

      settupAccount.then(function(value) { 
        account_id = value;
        //TODO: This is a temporary fix, error handling should be thought through
        if(account_id) { 
        	settupBudget(fiscal_year_id, account_id);
        }
      })

      function renderTables() { 
        //Populate the budget table with blank rows, account for fiscal years starting in any month
        for(var i=0; i<fiscal_array.length; i++) { 
          var tableid = "bika-units-budgeting-" + fiscal_array[i].id;
          var budget_table = dom.byId(tableid);

          for(var j=0; j<months.length; j++) { 
            budget_table.insertBefore(createRow(j), null);
          }

          var total_row = domConstruct.create("tr", {
            id : tableid + "-totalRow"
          }, budget_table);

          var total_label = domConstruct.create("td", { 
            colSpan : 2, 
            innerHTML : "Total"
          }, total_row);

          var budget_total = domConstruct.create("td", { 
            colSpan : 1,
            id : tableid + "-budgetTotal",

          }, total_row);

          function createRow(row_index) { 
            var tr = domConstruct.create("tr", { 
              id : tableid + '-' + row_index,
              class : "empty"
            });

            var td_period = domConstruct.create("td", {
              id : tableid + '-' + row_index + '-period'
            }, tr);
            //@sfount - Research Actual vs. Budget and implement correctly
            var td_actual = domConstruct.create("td", { 
              id : tableid + '-' + row_index + '-actual'
            }, tr);
            var td_budget = domConstruct.create("td", { 
              //@sfount - update this to give uniform naming convention 
              id : tableid + '-' + row_index + '-budgetRow'
            }, tr);

            return tr;
          }

        }
      }
    }
    
    function refreshUI() { 
      //basically duplicated code - not a good thing
      for(var i=0; i<fiscal_array.length; i++) { 
        var tableid = "bika-units-budgeting-" + fiscal_array[i].id;
        var budget_table = dom.byId(tableid);

        for(var j=0; j<months.length; j++) { 
          var tr = dom.byId(tableid + '-' + j);
          domAttr.set(tr, 'class', 'empty');

          //eugh
          var trchildren = tr.childNodes;
          for(child in trchildren) { 
            if(typeof trchildren[child]) { 
              domAttr.set(trchildren[child], "innerHTML", "");
            }
          }
        }

        var td_budget = dom.byId(tableid + '-budgetTotal');
        domAttr.set(td_budget, 'innerHTML', '');
      }
    }

    function settupBudget(fiscalyearid, accountid) { 

      //request information about current fiscal year
      var fyear = {};
        var fe = [{t : 'fiscal_year', c : ['id', 'number_of_months', 'start_month', 'start_year', 'previous_fiscal_year', 'next_fiscal_year']}];
        var fc = [{t : 'fiscal_year', cl : 'id', v : fiscalyearid, z : '='}];

        fyear.e = fe;
        fyear.c = fc;

        request.get('data/?' + JSON.stringify(fyear)).then(function(data) { 
            var fiscal_data = JSON.parse(data)[0];
          
          if(fiscal_data.previous_fiscal_year) { 
            requestBudget("previous", fiscal_data.previous_fiscal_year, accountid);
          }
          if(fiscal_data.next_fiscal_year) { 
            requestBudget("next", fiscal_data.next_fiscal_year, accountid);
          }
          requestBudget("current", fiscalyearid, accountid);
      });
    }

    function requestBudget(id, fiscalyearid, accountid) { 
      var budget_query = {
        'e' : [{
          t : 'period',
          c : ['period_start', 'period_stop'] 
        }, {
          t : 'budget',
          c : ['enterprise_id', 'account_id', 'period_id', 'budget']
        }],
        'jc': [{
          ts: ['period', 'budget'],
          c: ['id', 'period_id'],
          l: 'AND'
        }],
        'c': [{
          t: 'budget',
          cl: 'account_id',
          z: '=', 
          v: accountid, 
          l: 'AND' 
        }, 
        {
          t: 'period',
          cl: 'fiscal_year_id', 
          z: '=',
          v: fiscalyearid
      }]};

      var model = new Observable(Memory({}));
      var interface = new JsonRest({ 
        target : '/data/?' + JSON.stringify(budget_query)
      });
      var cache = new Cache(interface, model);
      cache.query();

      var budget_result = model.query();
      //@sfount - the methods returned here should be passed to whoever needs them, not stored at the top
      tablebind[id] = bindBudgetTable("bika-units-budgeting-" + id, budget_result, model);
      tablebind[id] = bindTotal("bika-units-budgeting-" + id, budget_result);

    } 

    function bindTotal(tableid, results) { 

      var total_view = dom.byId(tableid + "-budgetTotal");
      var cache_total = 0;
      ////////
      // This is a fix (read: hack) for keeping track of ID's 
      // -Items in dojos Stores must be UNIQUELY identifiable with a single column (ID). The budget table currently has a primary key consisting of multiple columns. Dojo kindly generates a random ID to satisfy its needs - unusable in this case.
      //  (1) Add a single column PK to every table in the bika database 
      //  (2) Alter dojo's Memory store to cater for the current `bika`.`budget` primary key`
      //  TODO: 
      //  -This should be resolved to adhere to the concept of having memory only in one place
      //  -Store original and new budgets to commit to server when needed
      ////////
      var cache_period = {};

      var bindHandle = results.observe(function(item, removedIndex, insertedIndex) { 

        var budget = Number(item.budget);
        //Use standard removed/insertedIndex method once Store IDs have been resolved
        if(!cache_period[item.period_id]) { 
          cache_period[item.period_id] = item.budget;
          cache_total += budget;
        } else { 
          cache_total -= cache_period[item.period_id];
          cache_total += budget;
          cache_period[item.period_id] = budget;
        }
        refreshView(cache_total);

      }, true);

      function refreshView(value) { 
        domAttr.set(total_view, "innerHTML", value);
      }

      function unbind() { 
        bindHandle.cancel();
      }

      return { 
        unbind: unbind
      }
    }

    function bindBudgetTable(tableid, results, model_ref) { 
      //summary: Bind the model for a given budget year to a budget table
      //TODO:
      //  -store row information in bindBudgetTable local variables - these should be used to access row elemnts, vs. queryying the DOM a second time

      var budget_table = dom.byId(tableid);
      var inputbind = {};

      var bindHandle = results.observe(function(item, removedIndex, insertedIndex) { 

        if(removedIndex > -1) { 
          //removeRow(removedIndex);
        }
        if(insertedIndex > -1) { 
          updateRow(item, insertedIndex);
        }
      }, true);

              

      //@sfount - this is probably shit
      function updateRow(item, index) { 
        
        //@sfount - assuming all fiscal years start in January - this number should be transformed respectively
        var month = new Date(item.period_start).getMonth();
        var row_id = tableid + "-" + month;

      
        domAttr.set(row_id, "class", '');
        //@sfount - 3 DOM querries, shouldn't happen
        domAttr.set(row_id + "-period", "innerHTML", formatDate(item.period_start));
        domAttr.set(row_id + "-actual", "innerHTML", '0.00');
        
        if(dom.byId(row_id + "-budget") != null) { 
          //reference input widget
          domAttr.set(row_id + "-budget", "value", item.budget);

          //If this is a new input
          //@sfount - this should be resolved (and not nescisary) by removing inputs on changing accounts/fiscal years
          if(!inputbind[item.id]) { 
            var td_budget_input = dom.byId(row_id + "-budget");
            inputbind[item.id] = on(td_budget_input, "keyup", function(e) { 
              ///////////
                //  Currently calling put method on store on every update, there may be a better way to this by updating the item (stored in the most recent query on the model) and obsering that individually 
              ///////////
                var newVal = td_budget_input.value;
                var validBudget = /^\d+(\.\d{1,2})?$/;

                //Check format of input
                if(validBudget.test(newVal)) { 
                  item.budget = Number(newVal);
                  model_ref.put(item);
              }
              });
          }
        } else { 

          //create input widget 
          var td_budget_input = domConstruct.create("input", { 
                value : item.budget,
                id : row_id + "-budget",
                pattern : '^[0-9]+(\.[0-9]{1,2})?$'
              }, dom.byId(row_id + "-budgetRow"));
              var input_error = false;

              //@sfount - again, undo these binds with dependencies vs. tracking them with an array
            inputbind[item.id] = on(td_budget_input, "keyup", function(e) { 
              var newVal = td_budget_input.value;
              var validBudget = /^\d+(\.\d{1,2})?$/;

              //Check format of input
              if(validBudget.test(newVal)) { 
                item.budget = Number(newVal);
                model_ref.put(item);
            }
            });   
        }
      }

      function removeRow(index) { 
        //Remove an item from the budget table
      }

      function unbind() { 
        bindHandle.cancel();
        for (index in inputbind) {
          inputbind[index].remove();
        }
      }

      return { 
        unbind: unbind
      }
    }

    //TODO 
    //  -updateAccount
    //  -load fiscal years based on enterprise 
    //  -update server (/flush to server update button)
    //  -inputs on totals, spread costs across months

    function updateAccount(enterprise_id) { 

      refreshUI();
      budget_dependencies.enterprise = false;
      budget_dependencies.fiscal = false;
      var update_query = {};
      var e = [{t : 'account', c : ['id', 'locked', 'account_txt', 'account_type_id', 'account_category']}];
      var c = [{t : 'account', cl : 'enterprise_id', v : enterprise_id, z : '='}];

      update_query.e = e;
      update_query.c = c;
     
      var format_update_query = '?' + JSON.stringify(update_query);

      console.log("Updating account_select with", enterprise_id);
      account_select.query = format_update_query;
      account_select.removeOption(account_select.getOptions());
      account_select.setStore(account_select.store);
      account_select.set('value', account_select.get('value'));

    } 

    function initAccountSelect(enterprise_id) { 
      var deferred = new Deferred();

      //Using a store to utilise the getLabel method - there may be a better way to do this with dojo/request?
        var account_select_store = new JsonRest({
          target: '/data/',
          getLabel: function(data) {
            return data.id + " - " + data.account_txt; //ref: bika.sql
          }
        });

        var account_query = {};
        var e = [{t : 'account', c : ['id', 'locked', 'account_txt', 'account_type_id', 'account_category']}];
        var c = [{t : 'account', cl : 'enterprise_id', v : enterprise_id, z : '='}];

        account_query.e = e;
        account_query.c = c;
       
        var format_account_query = '?' + JSON.stringify(account_query);

        account_select = new Select({
          store: account_select_store, 
          query: format_account_query
        }, "bika-units-budgeting-account");

        account_select.on("setStore", function() { 
          deferred.resolve(this.get('value'));
        });

        account_select.on("change", function(value) {
        console.log("account select change called");
        account_id = value;
            for(index in tablebind) { 
              tablebind[index].unbind();
            }
            tablebind = {};

          settupBudget(fiscal_year_id, account_id);
        });

        return deferred.promise;
    }

    ///////
    // Utility Functions
    ///////
    function formatDate(datestring) { 
      var date = new Date(datestring);
          return months[date.getMonth()] + ' ' + date.getFullYear(); 
    }

  });
</script>
