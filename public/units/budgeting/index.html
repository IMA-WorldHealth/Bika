<link href="../css/budget.css" rel="stylesheet">
<div id="units-budgeting-selection">
	<!--Placeholder for Account Select-->
	<div id="units-budgeting-account"></div>
</div>
<div id="units-budgeting-budgetDisplay">
	<fieldset>
		<legend>Previous Fiscal Year</legend>
		<table class="budget-table">
			<thead>
				<tr><th>Period</th><th>Actual</th><th>Budget</th></tr>
			</thead>
			<tbody id="units-budgeting-previous">
				<!--Generated with dojo-->
			</tbody>
		</table>
	</fieldset>
	<fieldset>
		<legend>Current Fiscal Year</legend>
		<table class="budget-table">
			<thead>
				<tr><th>Period</th><th>Actual</th><th>Budget</th></tr>
			</thead>
			<tbody id="units-budgeting-current">
				<!--Generated with dojo-->
			</tbody>
		</table>
	</fieldset>
	<fieldset>
		<legend>Next Fiscal Year</legend>
		<table class="budget-table">
			<thead>
				<tr><th>Period</th><th>Actual</th><th>Budget</th></tr>
			</thead>
			<tbody id="units-budgeting-next">
				<!--Generated with dojo-->
			</tbody>
		</table>
	</fieldset>
</div>

<script>
var current_model;
	require([
			//DOM manipulation
			"dojo/dom", 
			"dojo/dom-construct", 
			"dojo/query",
			"dojo/dom-attr", 
			//Stores
			"dojo/store/Memory",
			"dojo/store/Cache",
			"dojo/store/JsonRest",
			"dojo/store/Observable",
			//MVC
			//AJAX
			"dojo/request",
			//Events?
			"dojo/on",
			"dojo/Deferred",
			//Components
			"dijit/form/Select"
			], function(dom, domConstruct, query, domAttr, Memory, Cache, JsonRest, Observable, request, on, Deferred, Select){ 

		///////
		// module : budgeting
		// 
		// TODO: 
		// 	-[Discuss] Functions inside functions created every time a function is called? Place common functions at top level?
		// 	-[Discuss] Should this just be done with D-Grid to provide uniform table structure
		// 	-[Discuss] I read somewhere that var newFunc = function() { } is better practice than function() { }, is that true?
		// 	-Update comments - a lot of issues have been resolved etc.
		// 	-Unique ID for budget table (ref: store rant in code)
		// 	-Highlighting for errors on incorrect inputs for budgeting etc (Red box around invalid input)
		///////

		//label months provided by Date object (given 0 - 11)
		var months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

		//@sfount - I justified this at some point
		var fiscal_array = [{id : "previous"}, {id : "current"}, {id : "next"}];

		//@sfount - this data should be imported from the application structure 
		var enterprise_id = 101;
		var fiscal_year_id = 2013001;

		//@sfount - set with Selection at top of page
		var account_id;

		//Model
		var previous_interface = new JsonRest({
		});
		var previous_model = new Observable(Memory({}));
		var previous_cache;

		var current_interface;
		current_model = new Observable(Memory({}));
		var current_cache;

		var next_interface = new JsonRest({ 
		});
		var next_model = new Observable(Memory({}));
		var next_cache;

		//@sfount - re-write this to inject these value all the way through, stupid to have them accesible to everyone
		var bindlink_array = [];

		initUI();

		function initUI() { 

			renderTables();

			var settupAccount = initAccountSelect(enterprise_id);

			settupAccount.then(function(value) { 
				account_id = value;
				settupBudget(fiscal_year_id, account_id);
			})

			function renderTables() { 
				//Populate the budget table with blank rows, account for fiscal years starting in any month
				for(var i=0; i<fiscal_array.length; i++) { 
					var tableid = "units-budgeting-" + fiscal_array[i].id;
					var budget_table = dom.byId(tableid);

					for(var j=0; j<months.length; j++) { 
						budget_table.insertBefore(createRow(j), null);
					}

					var total_row = domConstruct.create("tr", {
						id : tableid + "-totalRow"
					}, budget_table);

					var total_label = domConstruct.create("td", { 
						colSpan : 2, 
						innerHTML : "Total"
					}, total_row);

					var budget_total = domConstruct.create("td", { 
						colSpan : 1,
						id : tableid + "-budgetTotal",

					}, total_row);

					//@sfount - is this a fly thing to do ?
					function createRow(row_index) { 
						var tr = domConstruct.create("tr", { 
							id : tableid + '-' + row_index,
							class : "empty"
						});
				        var td_period = domConstruct.create("td", {
				        	id : tableid + '-' + row_index + '-period'
				        }, tr);
				        //@sfount - Research Actual vs. Budget and implement correctly
				        var td_actual = domConstruct.create("td", { 
				        	id : tableid + '-' + row_index + '-actual'
				        }, tr);
				        var td_budget = domConstruct.create("td", { 
				        	//@sfount - update this to give uniform naming convention 
				        	id : tableid + '-' + row_index + '-budgetRow'
				        }, tr);

				        return tr;
					}

				}
			}
		}

		
		function settupBudget(fiscalyearid, accountid) { 

			//request information about current fiscal year
			var fyear = {};
		    var fe = [{t : 'fiscal_year', c : ['id', 'number_of_months', 'start_month', 'start_year', 'previous_fiscal_year', 'next_fiscal_year']}];
		    var fc = [{t : 'fiscal_year', cl : 'id', v : fiscalyearid, z : '='}];

		    fyear.e = fe;
		    fyear.c = fc;

		    request.get('data/?' + JSON.stringify(fyear)).then(function(data) { 
		        var fiscal_data = JSON.parse(data)[0];
		  		
		  		//@sfount - This is why combining models/interface/id/cache in an array is a good thing - UPDATE
		  		//request budgets
		  		if(fiscal_data.previous_fiscal_year) { 
		  			requestBudget("previous", fiscal_data.previous_fiscal_year, accountid, previous_interface, previous_model, previous_cache);
		  		}
		  		if(fiscal_data.next_fiscal_year) { 
		  			requestBudget("next", fiscal_data.next_fiscal_year, accountid, next_interface, next_model, next_cache);
		  		}
		  		requestBudget("current", fiscalyearid, accountid, current_interface, current_model, current_cache);
			});
		}

		//@sfount - make interface, model and cache more generic?
		//		  - this is shit
		function requestBudget(id, fiscalyearid, accountid, interface, model, cache) { 
			var budget_query = {
				'e' : [{
				  t : 'period',
				  c : ['period_start', 'period_stop'] 
				}, {
				  t : 'budget',
				  c : ['enterprise_id', 'account_id', 'period_id', 'budget']
				}],
				'jc': [{
				  ts: ['period', 'budget'],
				  c: ['id', 'period_id'],
				  l: 'AND'
				}],
				'c': [{
				  t: 'budget',
				  cl: 'account_id',
				  z: '=', 
				  v: accountid, 
				  l: 'AND' 
				}, 
				{
				  t: 'period',
				  cl: 'fiscal_year_id', 
				  z: '=',
				  v: fiscalyearid
			}]};

			model = new Observable(Memory({}));
			interface = new JsonRest({ 
				target : '/data/?' + JSON.stringify(budget_query)
			});
			cache = new Cache(interface, model);
			cache.query();

			var budget_result = model.query();
			//@sfount - the methods returned here should be passed to whoever needs them, not stored at the top
			bindlink_array.push(bindBudgetTable("units-budgeting-" + id, budget_result, model));
			bindlink_array.push(bindTotal("units-budgeting-" + id, budget_result));

		}	

		function bindTotal(tableid, results) { 
			var total_view = dom.byId(tableid + "-budgetTotal");
			var bindNumber = Math.round(Math.random() * 100);
			var cache_total = 0;
			console.log("bindTotal called - bindNumber: " + bindNumber);
			////////
			// This is a fix (read: hack) for keeping track of ID's 
			// -Items in dojos Stores must be UNIQUELY identifiable with a single column (ID). The budget table currently has a primary key consisting of multiple columns. Dojo kindly generates a random ID to satisfy its needs - unusable in this case.
			// 	(1) Add a single column PK to every table in the bika database 
			// 	(2) Alter dojo's Memory store to cater for the current `bika`.`budget` primary key`
			// 	TODO: 
			// 	-This should be resolved to adhere to the concept of having memory only in one place
			// 	-Store original and new budgets to commit to server when needed
			////////
			var cache_period = {};

			var bindHandle = results.observe(function(item, removedIndex, insertedIndex) { 
				//console.log("[Model - TotalView Bind] Updated; removed: ", removedIndex, " inserted: ", insertedIndex);

				console.log(bindNumber, " observing update");

				var budget = Number(item.budget);
				//Use standard removed/insertedIndex method once Store IDs have been resolved
				if(!cache_period[item.period_id]) { 
					cache_period[item.period_id] = item.budget;
					cache_total += budget;
				} else { 
					cache_total -= cache_period[item.period_id];
					cache_total += budget;
					cache_period[item.period_id] = budget;
				}
				refreshView(cache_total);

			}, true);

			function refreshView(value) { 
				domAttr.set(total_view, "innerHTML", value);
			}

			function unbind() { 
				bindHandle.cancel();
			}

			return { 
				unbind: unbind
			}
		}

		//View 
		function bindBudgetTable(tableid, results, model_ref) { 
			//summary: Bind the model for a given budget year to a budget table
			//TODO:
			//	-store row information in bindBudgetTable local variables - these should be used to access row elemnts, vs. queryying the DOM a second time

			var budget_table = dom.byId(tableid);
			var inputbind_array = new Array();
			//var table_rows = [];

			//Apply insertRow() function to all elements currently in results
			//results.forEach(insertRow);

			var bindHandle = results.observe(function(item, removedIndex, insertedIndex) { 

				if(removedIndex > -1) { 
					//removeRow(removedIndex);
				}
				if(insertedIndex > -1) { 
					updateRow(item, insertedIndex);
				}
			}, true);

            	

			//@sfount - this is probably shit
			function updateRow(item, index) { 
				
				//@sfount - assuming all fiscal years start in January - this number should be transformed respectively
				var month = new Date(item.period_start).getMonth();
				var row_id = tableid + "-" + month;

			
				domAttr.set(row_id, "class", '');
				//@sfount - 3 DOM querries, shouldn't happen
				domAttr.set(row_id + "-period", "innerHTML", formatDate(item.period_start));
				domAttr.set(row_id + "-actual", "innerHTML", '0.00');
				
				if(dom.byId(row_id + "-budget") != null) { 
					//reference input widget
					domAttr.set(row_id + "-budget", "value", item.budget);
				} else { 

					//create input widget 
					var td_budget_input = domConstruct.create("input", { 
			        	value : item.budget,
			        	id : row_id + "-budget", 
			        	pattern: "/^\d+(\.\d{1,2})?$/",
			        	required : 'required'
			        }, dom.byId(row_id + "-budgetRow"));
			        var input_error = false;

			        //@sfount - again, undo these binds with dependencies vs. tracking them with an array
				   	inputbind_array.push(on(td_budget_input, "keyup", function(e) { 
						///////////
				   		//	Currently calling put method on store on every update, there may be a better way to this by updating the item (stored in the most recent query on the model) and obsering that individually 
						///////////
				   		var newVal = td_budget_input.value;
				   		var validBudget = /^\d+(\.\d{1,2})?$/;

				   		//Check format of input
				   		if(validBudget.test(newVal)) { 
				   			item.budget = Number(newVal);
				   			model_ref.put(item);
						}
				   	}));		
				}

		        //table_rows.splice(i, 0, budget_table.insertBefore(tr, table_rows[i] || null));
			}

			function removeRow(index) { 
				//Remove an item from the budget table
			}

			function unbind() { 
				bindHandle.cancel();

				for (var i = inputbind_array.length - 1; i >= 0; i--) {
					inputbind_array[i].remove();
				};
				console.log("Unbind called");
			}

			return { 
				unbind: unbind
			}
		}

		function initAccountSelect(enterprise_id) { 
			var deferred = new Deferred();

		    var account_select_store = new JsonRest({
		      target: '/data/',
		      getLabel: function(data) {
		        return data.id + " - " + data.account_txt; // coding against the old trackerv6.sql db
		      }
		    });

		    var account_query = {};
		    var e = [{t : 'account', c : ['id', 'locked', 'account_txt', 'account_type_id', 'account_category']}];
		    var c = [{t : 'account', cl : 'enterprise_id', v : enterprise_id, z : '='}];

		    account_query.e = e;
		    account_query.c = c;
		   
		    var format_account_query = '?' + JSON.stringify(account_query);

		    var account_select = new Select({
		      store: account_select_store, 
		      query: format_account_query
		    }, "units-budgeting-account");

		    account_select.on("setStore", function() { 
		      deferred.resolve(this.get('value'));
		    });

		    account_select.on("change", function(value) {
		      //account = value; 
		      //paintBudget(fiscal_year, account);

	      	  for (var i = bindlink_array.length - 1; i >= 0; i--) {
	      	  	bindlink_array[i].unbind();
	      	  };
	      	  //Clear array
		      bindlink_array = new Array();

		      account_id = value;
		      settupBudget(fiscal_year_id, account_id);
		    });

		    return deferred.promise;
		}

		//Utility functions
		function formatDate(datestring) { 
			var date = new Date(datestring);
      		return months[date.getMonth()] + ' ' + date.getFullYear(); 
		}


	});
</script>
